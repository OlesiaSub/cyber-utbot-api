diff --git a/settings.gradle.kts b/settings.gradle.kts
index c80a375f..23132bd1 100644
--- a/settings.gradle.kts
+++ b/settings.gradle.kts
@@ -51,6 +51,8 @@ if (includeRiderInBuild.toBoolean()) {
 
 include("utbot-ui-commons")
 
+include("cyber-utbot-api")	// cyber
+
 if (pythonIde.split(",").contains(ideType)) {
     include("utbot-python")
     include("utbot-cli-python")
diff --git a/utbot-framework-api/src/main/kotlin/org/utbot/framework/TrustedLibraries.kt b/utbot-framework-api/src/main/kotlin/org/utbot/framework/TrustedLibraries.kt
index f0bd75cb..26e086f1 100644
--- a/utbot-framework-api/src/main/kotlin/org/utbot/framework/TrustedLibraries.kt
+++ b/utbot-framework-api/src/main/kotlin/org/utbot/framework/TrustedLibraries.kt
@@ -23,6 +23,8 @@ object TrustedLibraries {
         "org.w3c.dom",
     )
 
+    var extraTrustedLibraries: List<String> = emptyList()
+
     private val userTrustedLibraries: List<String>
         get() {
             val userTrustedLibrariesPath = System.getProperty(userTrustedLibrariesKey) ?: defaultUserTrustedLibrariesPath
@@ -45,5 +47,5 @@ object TrustedLibraries {
      * Represents prefixes of packages for trusted libraries -
      * as the union of [defaultTrustedLibraries] and [userTrustedLibraries].
      */
-    val trustedLibraries: Set<String> by lazy { (defaultTrustedLibraries + userTrustedLibraries).toSet() }
+    val trustedLibraries: Set<String> by lazy { (defaultTrustedLibraries + userTrustedLibraries + extraTrustedLibraries).toSet() }
 }
\ No newline at end of file
diff --git a/utbot-framework-api/src/main/kotlin/org/utbot/framework/plugin/api/util/ReflectionUtils.kt b/utbot-framework-api/src/main/kotlin/org/utbot/framework/plugin/api/util/ReflectionUtils.kt
index 5cfa8ab8..46a9bb05 100644
--- a/utbot-framework-api/src/main/kotlin/org/utbot/framework/plugin/api/util/ReflectionUtils.kt
+++ b/utbot-framework-api/src/main/kotlin/org/utbot/framework/plugin/api/util/ReflectionUtils.kt
@@ -42,6 +42,9 @@ val Class<*>.anyInstance: Any
 //                logger.warn(e) { "Can't create object with default ctor. Fallback to Unsafe." }
 //            }
 //        }
+        if (this.name == "org.cyber.utils.VulnerabilityException") {
+            return org.cyber.utils.VulnerabilityException("")
+        }
         return Reflection.unsafe.allocateInstance(this)
 
 //        val constructors = runCatching {
diff --git a/utbot-framework/src/main/kotlin/org/utbot/engine/ConstructedSootMethods.kt b/utbot-framework/src/main/kotlin/org/utbot/engine/ConstructedSootMethods.kt
index 67a5e89e..53116595 100644
--- a/utbot-framework/src/main/kotlin/org/utbot/engine/ConstructedSootMethods.kt
+++ b/utbot-framework/src/main/kotlin/org/utbot/engine/ConstructedSootMethods.kt
@@ -20,7 +20,7 @@ import soot.jimple.internal.JimpleLocal
 import soot.toolkits.graph.ExceptionalUnitGraph
 
 
-internal const val STATIC_INITIALIZER = "utbot\$staticInitializer"
+const val STATIC_INITIALIZER = "utbot\$staticInitializer"
 
 /**
  * Creates synthetic method with static initializer invocation and returns its graph.
diff --git a/utbot-framework/src/main/kotlin/org/utbot/engine/Mocks.kt b/utbot-framework/src/main/kotlin/org/utbot/engine/Mocks.kt
index 4b16c57d..62cea574 100644
--- a/utbot-framework/src/main/kotlin/org/utbot/engine/Mocks.kt
+++ b/utbot-framework/src/main/kotlin/org/utbot/engine/Mocks.kt
@@ -162,12 +162,12 @@ class UnexpectedMock(objectValue: ObjectValue): MockedObjectInfo() {
 /**
  * Service to mock things. Knows mock strategy, class under test and class hierarchy.
  */
-class Mocker(
-    private val strategy: MockStrategy,
+open class Mocker(
+    protected val strategy: MockStrategy,
     private val classUnderTest: ClassId,
     private val hierarchy: Hierarchy,
     chosenClassesToMockAlways: Set<ClassId>,
-    internal val mockListenerController: MockListenerController? = null,
+    val mockListenerController: MockListenerController? = null,
     private val applicationContext: ApplicationContext,
 ) {
     private val mocksAreDesired: Boolean = strategy != MockStrategy.NO_MOCKS
@@ -178,7 +178,7 @@ class Mocker(
      *
      * @see shouldMock
      */
-    fun mock(type: RefType, mockInfo: UtMockInfo): MockedObjectInfo {
+    open fun mock(type: RefType, mockInfo: UtMockInfo): MockedObjectInfo {
         val objectValue = if (shouldMock(type, mockInfo)) createMockObject(type, mockInfo) else null
         return construct(objectValue, mockInfo)
     }
@@ -186,7 +186,7 @@ class Mocker(
     /**
      * Unlike to [mock], unconditionally creates a mocked instance of the [type] using [mockInfo].
      */
-    fun forceMock(type: RefType, mockInfo: UtMockInfo): MockedObjectInfo {
+    open fun forceMock(type: RefType, mockInfo: UtMockInfo): MockedObjectInfo {
         mockListenerController?.onShouldMock(strategy, mockInfo)
 
         val objectValue = createMockObject(type, mockInfo)
@@ -220,7 +220,7 @@ class Mocker(
     /**
      * Constructs [MockedObjectInfo]: enriches given [mockedValue] with an information if mocking is expected or not.
      */
-    private fun construct(mockedValue: ObjectValue?, mockInfo: UtMockInfo): MockedObjectInfo {
+    protected fun construct(mockedValue: ObjectValue?, mockInfo: UtMockInfo): MockedObjectInfo {
         if (mockedValue == null) {
             return NoMock
         }
@@ -359,10 +359,10 @@ private fun createMockObject(type: RefType, mockInfo: UtMockInfo) =
     objectValue(type, mockInfo.addr, UtMockWrapper(type, mockInfo))
 
 private val mockCounter = AtomicInteger(0)
-private fun nextMockNumber() = mockCounter.incrementAndGet()
-private fun createMockLabel(number: Int) = "mock#$number"
+fun nextMockNumber() = mockCounter.incrementAndGet()
+fun createMockLabel(number: Int) = "mock#$number"
 
-class UtMockWrapper(
+open class UtMockWrapper(
     val type: RefType,
     private val mockInfo: UtMockInfo
 ) : WrapperInterface {
@@ -411,13 +411,13 @@ class UtMockWrapper(
 internal val utMockClass: SootClass
     get() = Scene.v().getSootClass(UtMock::class.qualifiedName)
 
-internal val utOverrideMockClass: SootClass
+val utOverrideMockClass: SootClass
     get() = Scene.v().getSootClass(UtOverrideMock::class.qualifiedName)
 
-internal val utLogicMockClass: SootClass
+val utLogicMockClass: SootClass
     get() = Scene.v().getSootClass(UtLogicMock::class.qualifiedName)
 
-internal val utArrayMockClass: SootClass
+val utArrayMockClass: SootClass
     get() = Scene.v().getSootClass(UtArrayMock::class.qualifiedName)
 
 internal val makeSymbolicMethod: SootMethod
diff --git a/utbot-framework/src/main/kotlin/org/utbot/engine/ObjectWrappers.kt b/utbot-framework/src/main/kotlin/org/utbot/engine/ObjectWrappers.kt
index 83e20e7f..bc202ddc 100644
--- a/utbot-framework/src/main/kotlin/org/utbot/engine/ObjectWrappers.kt
+++ b/utbot-framework/src/main/kotlin/org/utbot/engine/ObjectWrappers.kt
@@ -168,7 +168,7 @@ val wrapperToClass: Map<WrapperType, Set<TypeToBeWrapped>> =
         }
     }
 
-private fun MutableMap<TypeToBeWrapped, WrapperType>.putSootClass(
+fun MutableMap<TypeToBeWrapped, WrapperType>.putSootClass(
     key: KClass<*>,
     value: KClass<*>
 ) = putSootClass(key, Scene.v().getSootClass(value.jvmName).type) // It is important to use `jvmName` because `canonicalName` replaces `$` for nested classes to `.`
@@ -183,12 +183,12 @@ private fun MutableMap<TypeToBeWrapped, WrapperType>.putSootClass(
     value: SootClass
 ) = putSootClass(key, value.type)
 
-private fun MutableMap<TypeToBeWrapped, WrapperType>.putSootClass(
+fun MutableMap<TypeToBeWrapped, WrapperType>.putSootClass(
     key: KClass<*>,
     value: RefType
 ) = put(Scene.v().getSootClass(key.jvmName).type, value) // It is important to use `jvmName` because `canonicalName` replaces `$` for nested classes to `.`
 
-private val wrappers: Map<ClassId, (RefType, UtAddrExpression) -> ObjectValue> = mutableMapOf(
+var wrappers: Map<ClassId, (RefType, UtAddrExpression) -> ObjectValue> = mutableMapOf(
     wrap(java.lang.StringBuilder::class) { type, addr -> objectValue(type, addr, UtStringBuilderWrapper()) },
     wrap(java.lang.StringBuffer::class) { type, addr -> objectValue(type, addr, UtStringBufferWrapper()) },
     wrap(java.lang.CharSequence::class) { type, addr -> objectValue(type, addr, StringWrapper()) },
@@ -320,7 +320,7 @@ private val wrappers: Map<ClassId, (RefType, UtAddrExpression) -> ObjectValue> =
     }
 }
 
-private fun wrap(kClass: KClass<*>, implementation: (RefType, UtAddrExpression) -> ObjectValue) =
+fun wrap(kClass: KClass<*>, implementation: (RefType, UtAddrExpression) -> ObjectValue) =
     kClass.id to implementation
 
 internal fun wrapper(type: RefType, addr: UtAddrExpression): ObjectValue? =
diff --git a/utbot-framework/src/main/kotlin/org/utbot/engine/Resolver.kt b/utbot-framework/src/main/kotlin/org/utbot/engine/Resolver.kt
index 3aa92d57..d8ee1fab 100644
--- a/utbot-framework/src/main/kotlin/org/utbot/engine/Resolver.kt
+++ b/utbot-framework/src/main/kotlin/org/utbot/engine/Resolver.kt
@@ -216,7 +216,7 @@ class Resolver(
         state: MemoryState,
     ): UtArrayExpressionBase = memory.findArray(chunkDescriptor, state, staticFieldUnderResolving)
 
-    internal fun resolveModels(parameters: List<SymbolicValue>): ResolvedExecution {
+    fun resolveModels(parameters: List<SymbolicValue>): ResolvedExecution {
         var instrumentation: List<UtInstrumentation> = emptyList()
 
         val staticsBefore = memory.staticFields().map { (fieldId, states) -> fieldId to states.stateBefore }
@@ -1159,7 +1159,7 @@ private data class ArrayExtractionDetails(
     val oneDimensionalArray: UtArrayExpressionBase
 )
 
-internal val nullObjectAddr = UtAddrExpression(mkInt(SYMBOLIC_NULL_ADDR))
+val nullObjectAddr = UtAddrExpression(mkInt(SYMBOLIC_NULL_ADDR))
 
 
 fun SymbolicValue.isNullObject() =
diff --git a/utbot-framework/src/main/kotlin/org/utbot/engine/Traverser.kt b/utbot-framework/src/main/kotlin/org/utbot/engine/Traverser.kt
index 4e58b65b..02bf2d41 100644
--- a/utbot-framework/src/main/kotlin/org/utbot/engine/Traverser.kt
+++ b/utbot-framework/src/main/kotlin/org/utbot/engine/Traverser.kt
@@ -235,12 +235,12 @@ import java.lang.reflect.WildcardType
 private val CAUGHT_EXCEPTION = LocalVariable("@caughtexception")
 private val logger = KotlinLogging.logger {}
 
-class Traverser(
-    private val methodUnderTest: ExecutableId,
-    internal val typeRegistry: TypeRegistry,
-    internal val hierarchy: Hierarchy,
+open class Traverser(
+    protected val methodUnderTest: ExecutableId,
+    val typeRegistry: TypeRegistry,
+    val hierarchy: Hierarchy,
     // TODO HACK violation of encapsulation
-    internal val typeResolver: TypeResolver,
+    val typeResolver: TypeResolver,
     private val globalGraph: InterProceduralUnitGraph,
     private val mocker: Mocker,
     private val applicationContext: ApplicationContext,
@@ -253,7 +253,7 @@ class Traverser(
 
     // TODO: move this and other mutable fields to [TraversalContext]
     lateinit var environment: Environment
-    private val solver: UtSolver
+    protected val solver: UtSolver
         get() = environment.state.solver
 
     // TODO HACK violation of encapsulation
@@ -264,7 +264,7 @@ class Traverser(
         get() = environment.state.localVariableMemory
 
     //HACK (long strings)
-    internal var softMaxArraySize = 40
+    var softMaxArraySize = 40
 
     /**
      * Contains information about the generic types used in the parameters of the method under test.
@@ -276,9 +276,9 @@ class Traverser(
 
     private val preferredCexInstanceCache = mutableMapOf<ObjectValue, MutableSet<SootField>>()
 
-    private var queuedSymbolicStateUpdates = SymbolicStateUpdate()
+    var queuedSymbolicStateUpdates = SymbolicStateUpdate()
 
-    internal val objectCounter = ObjectCounter(TypeRegistry.objectCounterInitialValue)
+    val objectCounter = ObjectCounter(TypeRegistry.objectCounterInitialValue)
 
     private fun findNewAddr(insideStaticInitializer: Boolean): UtAddrExpression {
         val newAddr = objectCounter.createNewAddr()
@@ -289,13 +289,13 @@ class Traverser(
         val signedAddr = if (insideStaticInitializer) -newAddr else newAddr
         return UtAddrExpression(signedAddr)
     }
-    internal fun findNewAddr() = findNewAddr(environment.state.isInsideStaticInitializer).also { touchAddress(it) }
+    fun findNewAddr() = findNewAddr(environment.state.isInsideStaticInitializer).also { touchAddress(it) }
 
     private val dynamicInvokeResolver: DynamicInvokeResolver = DelegatingDynamicInvokeResolver()
 
     // Counter used for a creation symbolic results of "hashcode" and "equals" methods.
-    private var equalsCounter = 0
-    private var hashcodeCounter = 0
+    protected var equalsCounter = 0
+    protected var hashcodeCounter = 0
 
     // A counter for objects created as native method call result.
     private var unboundedConstCounter = 0
@@ -1119,7 +1119,7 @@ class Traverser(
         return UtMockInfoGenerator { mockAddr -> UtObjectMockInfo(type.id, mockAddr) }
     }
 
-    private fun updateGenericTypeInfoFromMethod(method: ExecutableId, value: ReferenceValue, parameterIndex: Int) {
+    protected fun updateGenericTypeInfoFromMethod(method: ExecutableId, value: ReferenceValue, parameterIndex: Int) {
         val type = extractParameterizedType(method, parameterIndex) as? ParameterizedType ?: return
 
         updateGenericTypeInfo(type, value)
@@ -1721,7 +1721,7 @@ class Traverser(
             else -> TODO("$expr")
         }
 
-    private fun initStringLiteral(stringWrapper: ObjectValue, value: String) {
+    fun initStringLiteral(stringWrapper: ObjectValue, value: String) {
         val typeStorage = TypeStorage.constructTypeStorageWithSingleType(utStringClass.type)
 
         queuedSymbolicStateUpdates += objectUpdate(
@@ -2047,7 +2047,7 @@ class Traverser(
     // Type is needed for null values: we should know, which null do we require.
     // If valueType is NullType, return typelessNullObject. It can happen in a situation,
     // where we cannot find the type, for example in condition (null == null)
-    private fun TraversalContext.resolve(
+    protected fun TraversalContext.resolve(
         value: Value,
         valueType: Type = value.type
     ): SymbolicValue = when (value) {
@@ -2598,7 +2598,7 @@ class Traverser(
      * @see Mocker.shouldMock
      * @see UtStaticMethodMockInfo
      */
-    private fun mockStaticMethod(method: SootMethod, args: List<SymbolicValue>): List<MethodResult>? {
+    protected fun mockStaticMethod(method: SootMethod, args: List<SymbolicValue>): List<MethodResult>? {
         val methodId = method.executableId as MethodId
         val declaringClassType = method.declaringClass.type
 
@@ -2634,7 +2634,7 @@ class Traverser(
         }
     }
 
-    private fun parametersContainPrivateAndProtectedTypes(method: SootMethod) =
+    protected fun parametersContainPrivateAndProtectedTypes(method: SootMethod) =
         method.parameterTypes.any { paramType ->
             (paramType.baseType as? RefType)?.let {
                 it.sootClass.isPrivate || it.sootClass.isProtected
@@ -2685,7 +2685,7 @@ class Traverser(
         )
     }
 
-    private fun TraversalContext.staticInvoke(invokeExpr: JStaticInvokeExpr): List<MethodResult> {
+    protected open fun TraversalContext.staticInvoke(invokeExpr: JStaticInvokeExpr): List<MethodResult> {
         val parameters = resolveParameters(invokeExpr.args, invokeExpr.method.parameterTypes)
         val result = mockMakeSymbolic(invokeExpr) ?: mockStaticMethod(invokeExpr.method, parameters)
 
@@ -2701,7 +2701,7 @@ class Traverser(
      * Each target defines/reduces object type to set of concrete (not abstract, not interface)
      * classes with particular method implementation.
      */
-    private fun TraversalContext.virtualAndInterfaceInvoke(
+    protected open fun TraversalContext.virtualAndInterfaceInvoke(
         base: Value,
         methodRef: SootMethodRef,
         parameters: List<Value>
@@ -2730,7 +2730,7 @@ class Traverser(
      *
      * Note: for some well known classes returns hardcoded choices.
      */
-    private fun findInvocationTargets(
+    protected fun findInvocationTargets(
         instance: ObjectValue,
         methodSubSignature: String
     ): List<InvocationTarget> {
@@ -2863,7 +2863,7 @@ class Traverser(
             .toList()
     }
 
-    private fun TraversalContext.specialInvoke(invokeExpr: JSpecialInvokeExpr): List<MethodResult> {
+    protected open fun TraversalContext.specialInvoke(invokeExpr: JSpecialInvokeExpr): List<MethodResult> {
         val instance = resolve(invokeExpr.base)
         if (instance !is ReferenceValue) error("We cannot run ${invokeExpr.methodRef} on $instance")
 
@@ -2880,7 +2880,7 @@ class Traverser(
         return commonInvokePart(invocation)
     }
 
-    private fun TraversalContext.dynamicInvoke(invokeExpr: JDynamicInvokeExpr): List<MethodResult> {
+    protected open fun TraversalContext.dynamicInvoke(invokeExpr: JDynamicInvokeExpr): List<MethodResult> {
         val invocation = with(dynamicInvokeResolver) { resolveDynamicInvoke(invokeExpr) }
 
         if (invocation == null) {
@@ -2901,7 +2901,7 @@ class Traverser(
      *
      * Returns results of native calls cause other calls push changes directly to path selector.
      */
-    private fun TraversalContext.commonInvokePart(invocation: Invocation): List<MethodResult> {
+    protected open fun TraversalContext.commonInvokePart(invocation: Invocation): List<MethodResult> {
         val method = invocation.method.executableId
 
         // This code is supposed to support generic information from signatures for nested methods.
@@ -3019,7 +3019,7 @@ class Traverser(
         return overriddenResults + originResults
     }
 
-    private fun TraversalContext.invoke(
+    protected open fun TraversalContext.invoke(
         target: InvocationTarget,
         parameters: List<SymbolicValue>
     ): List<MethodResult> = with(target.method) {
@@ -3265,7 +3265,7 @@ class Traverser(
      *
      * Proceeds overridden method as non-library.
      */
-    private fun TraversalContext.overrideInvocation(invocation: Invocation, target: InvocationTarget?): OverrideResult {
+    protected open fun TraversalContext.overrideInvocation(invocation: Invocation, target: InvocationTarget?): OverrideResult {
         // If we try to override invocation itself, the target is null, and we have to process
         // the instance from the invocation, otherwise take the one from the target
         val instance = if (target == null) invocation.instance else target.instance
@@ -3360,7 +3360,7 @@ class Traverser(
         return OverrideResult(success = false)
     }
 
-    private fun cloneArray(array: ArrayValue): MethodResult {
+    protected fun cloneArray(array: ArrayValue): MethodResult {
         val addr = findNewAddr()
 
         val type = array.type
@@ -3394,7 +3394,7 @@ class Traverser(
         return MethodResult(clone, constraints.asHardConstraint(), memoryUpdates = memoryUpdate)
     }
 
-    private fun TraversalContext.copyOf(parameters: List<SymbolicValue>): MethodResult {
+    protected fun TraversalContext.copyOf(parameters: List<SymbolicValue>): MethodResult {
         val src = parameters[0] as ArrayValue
         nullPointerExceptionCheck(src.addr)
 
@@ -3406,7 +3406,7 @@ class Traverser(
         return createArrayCopyWithSpecifiedLength(parameters)
     }
 
-    private fun TraversalContext.copyOfRange(parameters: List<SymbolicValue>): MethodResult {
+    protected fun TraversalContext.copyOfRange(parameters: List<SymbolicValue>): MethodResult {
         val original = parameters[0] as ArrayValue
         nullPointerExceptionCheck(original.addr)
 
@@ -3458,7 +3458,7 @@ class Traverser(
     private fun processNativeMethod(target: InvocationTarget): List<MethodResult> =
         listOf(unboundedVariable(name = "nativeConst", target.method))
 
-    private fun unboundedVariable(name: String, method: SootMethod): MethodResult {
+    protected fun unboundedVariable(name: String, method: SootMethod): MethodResult {
         val value = when (val returnType = method.returnType) {
             is RefType -> createObject(findNewAddr(), returnType, useConcreteType = true)
             is ArrayType -> createArray(findNewAddr(), returnType, useConcreteType = true)
@@ -3484,7 +3484,7 @@ class Traverser(
             .firstOrNull { it.canRetrieveBody() || it.isNative }
     }
 
-    private fun TraversalContext.pushToPathSelector(
+    protected fun TraversalContext.pushToPathSelector(
         graph: ExceptionalUnitGraph,
         caller: ReferenceValue?,
         callParameters: List<SymbolicValue>,
@@ -3649,7 +3649,7 @@ class Traverser(
         return if (negate) mkNot(eq) else eq
     }
 
-    private fun TraversalContext.nullPointerExceptionCheck(addr: UtAddrExpression) {
+    protected fun TraversalContext.nullPointerExceptionCheck(addr: UtAddrExpression) {
         val canBeNull = addrEq(addr, nullObjectAddr)
         val canNotBeNull = mkNot(canBeNull)
         val notMarked = mkEq(memory.isSpeculativelyNotNull(addr), mkFalse())
@@ -3994,7 +3994,7 @@ class Traverser(
         )
     }
 
-    private fun TraversalContext.processResult(symbolicResult: SymbolicResult) {
+    protected open fun TraversalContext.processResult(symbolicResult: SymbolicResult) {
         val resolvedParameters = environment.state.parameters.map { it.value }
 
         //choose types that have biggest priority
@@ -4139,7 +4139,7 @@ class Traverser(
         )
     }
 
-    private fun pop(methodResultWithUpdates: MethodResult): ExecutionState {
+    protected fun pop(methodResultWithUpdates: MethodResult): ExecutionState {
         return environment.state.pop(methodResultWithUpdates)
     }
 }
\ No newline at end of file
diff --git a/utbot-framework/src/main/kotlin/org/utbot/engine/UtBotSymbolicEngine.kt b/utbot-framework/src/main/kotlin/org/utbot/engine/UtBotSymbolicEngine.kt
index 87c54616..917c7a12 100644
--- a/utbot-framework/src/main/kotlin/org/utbot/engine/UtBotSymbolicEngine.kt
+++ b/utbot-framework/src/main/kotlin/org/utbot/engine/UtBotSymbolicEngine.kt
@@ -63,7 +63,7 @@ class EngineController {
 }
 
 //for debugging purpose only
-private var stateSelectedCount = 0
+var stateSelectedCount = 0
 
 private val defaultIdGenerator = ReferencePreservingIntIdGenerator()
 
@@ -98,33 +98,33 @@ private fun pathSelector(graph: InterProceduralUnitGraph, typeRegistry: TypeRegi
         }
     }
 
-class UtBotSymbolicEngine(
-    private val controller: EngineController,
-    private val methodUnderTest: ExecutableId,
+open class UtBotSymbolicEngine(
+    protected val controller: EngineController,
+    protected val methodUnderTest: ExecutableId,
     classpath: String,
     dependencyPaths: String,
     val mockStrategy: MockStrategy = NO_MOCKS,
     chosenClassesToMockAlways: Set<ClassId>,
     applicationContext: ApplicationContext,
-    private val solverTimeoutInMillis: Int = checkSolverTimeoutMillis
+    protected val solverTimeoutInMillis: Int = checkSolverTimeoutMillis
 ) : UtContextInitializer() {
-    private val graph = methodUnderTest.sootMethod.jimpleBody().apply {
+    protected val graph = methodUnderTest.sootMethod.jimpleBody().apply {
         logger.trace { "JIMPLE for $methodUnderTest:\n$this" }
     }.graph()
 
     private val methodUnderAnalysisStmts: Set<Stmt> = graph.stmts.toSet()
-    private val globalGraph = InterProceduralUnitGraph(graph)
-    private val typeRegistry: TypeRegistry = TypeRegistry()
-    private val pathSelector: PathSelector = pathSelector(globalGraph, typeRegistry)
+    protected val globalGraph = InterProceduralUnitGraph(graph)
+    protected val typeRegistry: TypeRegistry = TypeRegistry()
+    protected var pathSelector: PathSelector = pathSelector(globalGraph, typeRegistry)
 
-    internal val hierarchy: Hierarchy = Hierarchy(typeRegistry)
+    protected val hierarchy: Hierarchy = Hierarchy(typeRegistry)
 
     // TODO HACK violation of encapsulation
-    internal val typeResolver: TypeResolver = TypeResolver(typeRegistry, hierarchy)
+    protected val typeResolver: TypeResolver = TypeResolver(typeRegistry, hierarchy)
 
-    private val classUnderTest: ClassId = methodUnderTest.classId
+    protected val classUnderTest: ClassId = methodUnderTest.classId
 
-    private val mocker: Mocker = Mocker(
+    protected var mocker: Mocker = Mocker(
         mockStrategy,
         classUnderTest,
         hierarchy,
@@ -137,9 +137,9 @@ class UtBotSymbolicEngine(
 
     fun detachMockListener(mockListener: MockListener) = mocker.mockListenerController?.detach(mockListener)
 
-    private val statesForConcreteExecution: MutableList<ExecutionState> = mutableListOf()
+    protected val statesForConcreteExecution: MutableList<ExecutionState> = mutableListOf()
 
-    private val traverser = Traverser(
+    protected var traverser = Traverser(
         methodUnderTest,
         typeRegistry,
         hierarchy,
@@ -150,9 +150,9 @@ class UtBotSymbolicEngine(
     )
 
     //HACK (long strings)
-    internal var softMaxArraySize = 40
+    protected var softMaxArraySize = 40
 
-    private val concreteExecutor =
+    protected val concreteExecutor =
         ConcreteExecutor(
             UtExecutionInstrumentation,
             classpath,
@@ -162,7 +162,7 @@ class UtBotSymbolicEngine(
         if (enableFeatureProcess) EngineAnalyticsContext.featureProcessorFactory(globalGraph) else null
 
 
-    private val trackableResources: MutableSet<AutoCloseable> = mutableSetOf()
+    protected val trackableResources: MutableSet<AutoCloseable> = mutableSetOf()
 
     private fun postTraverse() {
         for (r in trackableResources)
@@ -186,7 +186,7 @@ class UtBotSymbolicEngine(
         .onStart { preTraverse() }
         .onCompletion { postTraverse() }
 
-    private fun traverseImpl(): Flow<UtResult> = flow {
+    protected open fun traverseImpl(): Flow<UtResult> = flow {
 
         require(trackableResources.isEmpty())
 
@@ -434,7 +434,7 @@ class UtBotSymbolicEngine(
         }
     }
 
-    private suspend fun FlowCollector<UtResult>.emitFailedConcreteExecutionResult(
+    protected suspend fun FlowCollector<UtResult>.emitFailedConcreteExecutionResult(
         stateBefore: EnvironmentModels,
         e: InstrumentedProcessDeathException
     ) {
@@ -446,7 +446,7 @@ class UtBotSymbolicEngine(
         emit(failedConcreteExecution)
     }
 
-    private suspend fun FlowCollector<UtResult>.consumeTerminalState(
+    protected open suspend fun FlowCollector<UtResult>.consumeTerminalState(
         state: ExecutionState,
     ) {
         // some checks to be sure the state is correct
@@ -571,7 +571,7 @@ class UtBotSymbolicEngine(
      * Collects entry method statement path for ML. Eliminates duplicated statements, e.g. assignment with invocation
      * in right part.
      */
-    private fun entryMethodPath(state: ExecutionState): MutableList<Step> {
+    protected fun entryMethodPath(state: ExecutionState): MutableList<Step> {
         val entryPath = mutableListOf<Step>()
         state.fullPath().forEach { step ->
             // TODO: replace step.stmt in methodUnderAnalysisStmts with step.depth == 0
@@ -584,7 +584,7 @@ class UtBotSymbolicEngine(
     }
 }
 
-private fun ResolvedModels.constructStateForMethod(methodUnderTest: ExecutableId): EnvironmentModels {
+fun ResolvedModels.constructStateForMethod(methodUnderTest: ExecutableId): EnvironmentModels {
     val (thisInstanceBefore, paramsBefore) = when {
         methodUnderTest.isStatic -> null to parameters
         methodUnderTest.isConstructor -> null to parameters.drop(1)
@@ -593,7 +593,7 @@ private fun ResolvedModels.constructStateForMethod(methodUnderTest: ExecutableId
     return EnvironmentModels(thisInstanceBefore, paramsBefore, statics)
 }
 
-private suspend fun ConcreteExecutor<UtConcreteExecutionResult, UtExecutionInstrumentation>.executeConcretely(
+suspend fun ConcreteExecutor<UtConcreteExecutionResult, UtExecutionInstrumentation>.executeConcretely(
     methodUnderTest: ExecutableId,
     stateBefore: EnvironmentModels,
     instrumentation: List<UtInstrumentation>,
@@ -615,7 +615,7 @@ private suspend fun ConcreteExecutor<UtConcreteExecutionResult, UtExecutionInstr
  * For example, not fully visited map can contain duplicate keys that leads to incorrect behaviour.
  * To prevent it, we need to add visited constraint for each MUT parameter-wrapper in state.
  */
-private fun ExecutionState.withWrapperConsistencyChecks(): ExecutionState {
+fun ExecutionState.withWrapperConsistencyChecks(): ExecutionState {
     val visitedConstraints = mutableSetOf<UtBoolExpression>()
     val methodUnderTestWrapperParameters = methodUnderTestParameters.filterNot { it.asWrapperOrNull == null }
     val methodUnderTestWrapperParametersAddresses = methodUnderTestWrapperParameters.map { it.addr }.toSet()
@@ -655,7 +655,7 @@ private fun makeWrapperConsistencyCheck(
     visitedConstraints += mkEq(visitedSelectExpression, mkInt(1))
 }
 
-private fun UtConcreteExecutionResult.violatesUtMockAssumption(): Boolean {
+fun UtConcreteExecutionResult.violatesUtMockAssumption(): Boolean {
     // We should compare FQNs instead of `if (... is UtMockAssumptionViolatedException)`
     // because the exception from the `concreteExecutionResult` is loaded by user's ClassLoader,
     // but the `UtMockAssumptionViolatedException` is loaded by the current ClassLoader,
@@ -663,5 +663,5 @@ private fun UtConcreteExecutionResult.violatesUtMockAssumption(): Boolean {
     return result.exceptionOrNull()?.javaClass?.name == UtMockAssumptionViolatedException::class.java.name
 }
 
-private fun checkStaticMethodsMock(execution: UtSymbolicExecution) =
+fun checkStaticMethodsMock(execution: UtSymbolicExecution) =
     execution.instrumentation.any { it is UtStaticMethodInstrumentation}
\ No newline at end of file
diff --git a/utbot-framework/src/main/kotlin/org/utbot/engine/pc/UtSolver.kt b/utbot-framework/src/main/kotlin/org/utbot/engine/pc/UtSolver.kt
index 7d98030f..66b3b87c 100644
--- a/utbot-framework/src/main/kotlin/org/utbot/engine/pc/UtSolver.kt
+++ b/utbot-framework/src/main/kotlin/org/utbot/engine/pc/UtSolver.kt
@@ -302,6 +302,7 @@ data class UtSolver constructor(
                 }
                 else -> {
                     logger.debug { "Reason of UNKNOWN: ${z3Solver.reasonUnknown}" }
+                    println("z3 Reason of UNKNOWN: ${z3Solver.reasonUnknown}")
                     if (translatedSoft.isEmpty()) {
                         logger.debug { "No soft constraints left, return UNKNOWN" }
                         logger.trace { "Constraints lead to unknown: ${z3Solver.assertions.joinToString("\n")} " }
diff --git a/utbot-framework/src/main/kotlin/org/utbot/engine/selectors/PathSelectorBuilder.kt b/utbot-framework/src/main/kotlin/org/utbot/engine/selectors/PathSelectorBuilder.kt
index 5516d548..4a67f166 100644
--- a/utbot-framework/src/main/kotlin/org/utbot/engine/selectors/PathSelectorBuilder.kt
+++ b/utbot-framework/src/main/kotlin/org/utbot/engine/selectors/PathSelectorBuilder.kt
@@ -545,7 +545,7 @@ class MLSelectorBuilder internal constructor(
 /**
  * Base pathSelectorBuilder that maintains context to attach necessary statistics to graph
  */
-sealed class PathSelectorBuilder<out T : PathSelector>(
+abstract class PathSelectorBuilder<out T : PathSelector>(
     protected val graph: InterProceduralUnitGraph,
     protected var context: PathSelectorContext
 ) {
diff --git a/utbot-framework/src/main/kotlin/org/utbot/engine/selectors/strategies/GraphViz.kt b/utbot-framework/src/main/kotlin/org/utbot/engine/selectors/strategies/GraphViz.kt
index 1cf9c38e..41289f09 100644
--- a/utbot-framework/src/main/kotlin/org/utbot/engine/selectors/strategies/GraphViz.kt
+++ b/utbot-framework/src/main/kotlin/org/utbot/engine/selectors/strategies/GraphViz.kt
@@ -74,6 +74,7 @@ class GraphViz(
         update()
 
         val path = Paths.get(graphVisPathString, "UseVisJs.html")
+        println("Debug visualization: $path")
 
         logger.debug { "Debug visualization: $path" }
 
diff --git a/utbot-framework/src/main/kotlin/org/utbot/engine/types/TypeResolver.kt b/utbot-framework/src/main/kotlin/org/utbot/engine/types/TypeResolver.kt
index e7c5e47d..f151da13 100644
--- a/utbot-framework/src/main/kotlin/org/utbot/engine/types/TypeResolver.kt
+++ b/utbot-framework/src/main/kotlin/org/utbot/engine/types/TypeResolver.kt
@@ -529,14 +529,14 @@ internal val CLASS_REF_NUM_DIMENSIONS_DESCRIPTOR: MemoryChunkDescriptor
         IntType.v()
     )
 
-internal val CLASS_REF_SOOT_CLASS: SootClass
+val CLASS_REF_SOOT_CLASS: SootClass
     get() = Scene.v().getSootClass(CLASS_REF_CLASSNAME)
-internal val ARRAYS_SOOT_CLASS: SootClass
+val ARRAYS_SOOT_CLASS: SootClass
     get() = Scene.v().getSootClass(java.util.Arrays::class.java.canonicalName)
 
-internal val OBJECT_TYPE: RefType
+val OBJECT_TYPE: RefType
     get() = Scene.v().getSootClass(Object::class.java.canonicalName).type
-internal val STRING_TYPE: RefType
+val STRING_TYPE: RefType
     get() = Scene.v().getSootClass(String::class.java.canonicalName).type
 internal val STRING_BUILDER_TYPE: RefType
     get() = Scene.v().getSootClass(java.lang.StringBuilder::class.java.canonicalName).type
@@ -550,7 +550,7 @@ internal val OPTIONAL_LONG_TYPE: RefType
     get() = Scene.v().getSootClass(java.util.OptionalLong::class.java.canonicalName).type
 internal val OPTIONAL_DOUBLE_TYPE: RefType
     get() = Scene.v().getSootClass(java.util.OptionalDouble::class.java.canonicalName).type
-internal val CLASS_REF_TYPE: RefType
+val CLASS_REF_TYPE: RefType
     get() = CLASS_REF_SOOT_CLASS.type
 internal val THREAD_TYPE: RefType
     get() = Scene.v().getSootClass(Thread::class.java.canonicalName).type
@@ -567,15 +567,15 @@ internal val COUNT_DOWN_LATCH_TYPE: RefType
 internal val SECURITY_MANAGER_TYPE: RefType
     get() = Scene.v().getSootClass(SecurityManager::class.java.canonicalName).type
 
-internal val NEW_INSTANCE_SIGNATURE: String = CLASS_REF_SOOT_CLASS.getMethodByName("newInstance").subSignature
+val NEW_INSTANCE_SIGNATURE: String = CLASS_REF_SOOT_CLASS.getMethodByName("newInstance").subSignature
 
-internal val HASHCODE_SIGNATURE: String =
+val HASHCODE_SIGNATURE: String =
     Scene.v()
         .getSootClass(Object::class.java.canonicalName)
         .getMethodByName(Object::hashCode.name)
         .subSignature
 
-internal val EQUALS_SIGNATURE: String =
+val EQUALS_SIGNATURE: String =
     Scene.v()
         .getSootClass(Object::class.java.canonicalName)
         .getMethodByName(Object::equals.name)
diff --git a/utbot-framework/src/main/kotlin/org/utbot/framework/codegen/CodeGenerator.kt b/utbot-framework/src/main/kotlin/org/utbot/framework/codegen/CodeGenerator.kt
index 72cbd385..3646ba60 100644
--- a/utbot-framework/src/main/kotlin/org/utbot/framework/codegen/CodeGenerator.kt
+++ b/utbot-framework/src/main/kotlin/org/utbot/framework/codegen/CodeGenerator.kt
@@ -47,7 +47,7 @@ open class CodeGenerator(
     testClassPackageName: String = classUnderTest.packageName,
 ) {
 
-    private val logger = KotlinLogging.logger {}
+    protected val logger = KotlinLogging.logger {}
 
     open var context: CgContext = CgContext(
         classUnderTest = classUnderTest,
@@ -88,7 +88,7 @@ open class CodeGenerator(
         }
     }
 
-    private fun generateForSimpleClass(testSets: List<CgMethodTestSet>): CodeGeneratorResult {
+    protected open fun generateForSimpleClass(testSets: List<CgMethodTestSet>): CodeGeneratorResult {
         val astConstructor = CgSimpleTestClassConstructor(context)
         val testClassModel = SimpleTestClassModelBuilder(context).createTestClassModel(classUnderTest, testSets)
 
@@ -122,7 +122,7 @@ open class CodeGenerator(
         )
     }
 
-    private fun renderToString(testClassFile: CgClassFile): String {
+    protected fun renderToString(testClassFile: CgClassFile): String {
         logger.info { "Rendering phase started at ${now()}" }
         val renderer = CgAbstractRenderer.makeRenderer(context)
         testClassFile.accept(renderer)
@@ -131,7 +131,7 @@ open class CodeGenerator(
         return renderer.toString()
     }
 
-    private fun now() = LocalDateTime.now().format(DateTimeFormatter.ofPattern("HH:mm:ss.SSS"))
+    protected fun now() = LocalDateTime.now().format(DateTimeFormatter.ofPattern("HH:mm:ss.SSS"))
 
     /**
      * Wrapper function that configures context as needed for utbot-online:
diff --git a/utbot-framework/src/main/kotlin/org/utbot/framework/codegen/domain/Domain.kt b/utbot-framework/src/main/kotlin/org/utbot/framework/codegen/domain/Domain.kt
index 8a3b48e9..14211081 100644
--- a/utbot-framework/src/main/kotlin/org/utbot/framework/codegen/domain/Domain.kt
+++ b/utbot-framework/src/main/kotlin/org/utbot/framework/codegen/domain/Domain.kt
@@ -793,3 +793,9 @@ data class ModelId private constructor(
     }
 }
 
+object CyberOk {    // TODO(replace)
+    val vulnerability = BuiltinClassId(
+        canonicalName = "org.cyber.utils.VulnerabilityInfo",
+        simpleName = "VulnerabilityInfo"
+    )
+}
diff --git a/utbot-framework/src/main/kotlin/org/utbot/framework/codegen/domain/models/CgElement.kt b/utbot-framework/src/main/kotlin/org/utbot/framework/codegen/domain/models/CgElement.kt
index 894db6db..b9dabbe7 100644
--- a/utbot-framework/src/main/kotlin/org/utbot/framework/codegen/domain/models/CgElement.kt
+++ b/utbot-framework/src/main/kotlin/org/utbot/framework/codegen/domain/models/CgElement.kt
@@ -283,9 +283,9 @@ sealed class CgMethod(open val isStatic: Boolean) : CgElement {
     abstract val name: String
     abstract val returnType: ClassId
     abstract val parameters: List<CgParameterDeclaration>
-    abstract val statements: List<CgStatement>
+    abstract var statements: List<CgStatement>
     abstract val exceptions: Set<ClassId>
-    abstract val annotations: List<CgAnnotation>
+    abstract var annotations: List<CgAnnotation>
     abstract val documentation: CgDocumentationComment
     abstract val requiredFields: List<CgParameterDeclaration>
     abstract val visibility: VisibilityModifier
@@ -295,9 +295,9 @@ class CgTestMethod(
     override val name: String,
     override val returnType: ClassId,
     override val parameters: List<CgParameterDeclaration>,
-    override val statements: List<CgStatement>,
+    override var statements: List<CgStatement>,
     override val exceptions: Set<ClassId>,
-    override val annotations: List<CgAnnotation>,
+    override var annotations: List<CgAnnotation>,
     override val visibility: VisibilityModifier = VisibilityModifier.PUBLIC,
     val type: CgTestMethodType,
     override val documentation: CgDocumentationComment = CgDocumentationComment(emptyList()),
@@ -306,9 +306,9 @@ class CgTestMethod(
 
 class CgFrameworkUtilMethod(
     override val name: String,
-    override val statements: List<CgStatement>,
+    override var statements: List<CgStatement>,
     override val exceptions: Set<ClassId>,
-    override val annotations: List<CgAnnotation>,
+    override var annotations: List<CgAnnotation>,
     override val visibility: VisibilityModifier = VisibilityModifier.PUBLIC,
 ) : CgMethod(isStatic = false) {
     override val returnType: ClassId = voidClassId
@@ -319,22 +319,22 @@ class CgFrameworkUtilMethod(
 
 class CgErrorTestMethod(
     override val name: String,
-    override val statements: List<CgStatement>,
+    override var statements: List<CgStatement>,
     override val documentation: CgDocumentationComment = CgDocumentationComment(emptyList()),
     override val visibility: VisibilityModifier = VisibilityModifier.PUBLIC,
 ) : CgMethod(isStatic = false) {
     override val exceptions: Set<ClassId> = emptySet()
     override val returnType: ClassId = voidClassId
     override val parameters: List<CgParameterDeclaration> = emptyList()
-    override val annotations: List<CgAnnotation> = emptyList()
+    override var annotations: List<CgAnnotation> = emptyList()
     override val requiredFields: List<CgParameterDeclaration> = emptyList()
 }
 
 class CgParameterizedTestDataProviderMethod(
     override val name: String,
-    override val statements: List<CgStatement>,
+    override var statements: List<CgStatement>,
     override val returnType: ClassId,
-    override val annotations: List<CgAnnotation>,
+    override var annotations: List<CgAnnotation>,
     override val exceptions: Set<ClassId>,
     override val visibility: VisibilityModifier = VisibilityModifier.PUBLIC,
 ) : CgMethod(isStatic = true) {
@@ -618,7 +618,7 @@ object CgContinueStatement : CgStatement
 
 class CgDeclaration(
     val variableType: ClassId,
-    val variableName: String,
+    var variableName: String,
     val initializer: CgExpression?,
     val isMutable: Boolean = false,
 ) : CgStatement {
diff --git a/utbot-framework/src/main/kotlin/org/utbot/framework/codegen/tree/ututils/UtilClassKind.kt b/utbot-framework/src/main/kotlin/org/utbot/framework/codegen/tree/ututils/UtilClassKind.kt
index 6df90f71..7b318f96 100644
--- a/utbot-framework/src/main/kotlin/org/utbot/framework/codegen/tree/ututils/UtilClassKind.kt
+++ b/utbot-framework/src/main/kotlin/org/utbot/framework/codegen/tree/ututils/UtilClassKind.kt
@@ -120,7 +120,7 @@ sealed class UtilClassKind(
          * @return `null` if [CgContext.utilMethodProvider] is not [UtilClassFileMethodProvider],
          * because it means that util methods will be taken from some other provider (e.g. [TestClassUtilMethodProvider]).
          */
-        internal fun fromCgContextOrNull(context: CgContext): UtilClassKind? {
+        fun fromCgContextOrNull(context: CgContext): UtilClassKind? {
             if (context.requiredUtilMethods.isEmpty()) return null
             if (!context.mockFrameworkUsed) {
                 return RegularUtUtils(context.codegenLanguage)
diff --git a/utbot-framework/src/main/kotlin/org/utbot/framework/plugin/api/TestCaseGenerator.kt b/utbot-framework/src/main/kotlin/org/utbot/framework/plugin/api/TestCaseGenerator.kt
index a7346a26..e40e3900 100644
--- a/utbot-framework/src/main/kotlin/org/utbot/framework/plugin/api/TestCaseGenerator.kt
+++ b/utbot-framework/src/main/kotlin/org/utbot/framework/plugin/api/TestCaseGenerator.kt
@@ -56,7 +56,7 @@ import kotlin.math.min
 open class TestCaseGenerator(
     private val buildDirs: List<Path>,
     private val classpath: String?,
-    private val dependencyPaths: String,
+    protected val dependencyPaths: String,
     private val jdkInfo: JdkInfo,
     val engineActions: MutableList<(UtBotSymbolicEngine) -> Unit> = mutableListOf(),
     val isCanceled: () -> Boolean = { false },
@@ -66,7 +66,7 @@ open class TestCaseGenerator(
     private val logger: KLogger = KotlinLogging.logger {}
     private val timeoutLogger: KLogger = KotlinLogging.logger(logger.name + ".timeout")
 
-    private val classpathForEngine: String
+    protected val classpathForEngine: String
         get() = (buildDirs + listOfNotNull(classpath)).joinToString(File.pathSeparator)
 
     init {
@@ -252,7 +252,7 @@ open class TestCaseGenerator(
         }
     }
 
-    private fun createSymbolicEngine(
+    protected open fun createSymbolicEngine(
         controller: EngineController,
         method: ExecutableId,
         mockStrategyApi: MockStrategyApi,
diff --git a/utbot-framework/src/main/kotlin/org/utbot/framework/util/SootUtils.kt b/utbot-framework/src/main/kotlin/org/utbot/framework/util/SootUtils.kt
index f8feddc7..d3f33703 100644
--- a/utbot-framework/src/main/kotlin/org/utbot/framework/util/SootUtils.kt
+++ b/utbot-framework/src/main/kotlin/org/utbot/framework/util/SootUtils.kt
@@ -137,7 +137,7 @@ private fun addBasicClasses(vararg classes: Class<*>) {
     }
 }
 
-private val classesToLoad = arrayOf(
+var classesToLoad = arrayOf(
     org.utbot.engine.overrides.collections.AbstractCollection::class,
     org.utbot.api.mock.UtMock::class,
     org.utbot.engine.overrides.UtOverrideMock::class,
diff --git a/utbot-framework-api/src/main/java/org/cyber/utils/Utils.java b/utbot-framework-api/src/main/java/org/cyber/utils/Utils.java
new file mode 100644
index 00000000..7ea883cf
--- /dev/null
+++ b/utbot-framework-api/src/main/java/org/cyber/utils/Utils.java
@@ -0,0 +1,13 @@
+package org.cyber.utils;
+
+public class Utils {    // FIXME(copy from cyber-utbot-api)
+    public static void vulnerabilityAssert(boolean predicateResult, String message) throws VulnerabilityException {
+        if (!predicateResult) {
+            throw new VulnerabilityException(message);
+        }
+    }
+
+    public static void vulnerabilityAssertByMsg(String message) throws VulnerabilityException {
+        throw new VulnerabilityException(message);
+    }
+}
diff --git a/utbot-framework-api/src/main/java/org/cyber/utils/VulnerabilityException.java b/utbot-framework-api/src/main/java/org/cyber/utils/VulnerabilityException.java
new file mode 100644
index 00000000..959013b0
--- /dev/null
+++ b/utbot-framework-api/src/main/java/org/cyber/utils/VulnerabilityException.java
@@ -0,0 +1,7 @@
+package org.cyber.utils;
+
+public class VulnerabilityException extends RuntimeException {  // FIXME(copy from cyber-utbot-api)
+    public VulnerabilityException(String errorMessage) {
+        super(errorMessage);
+    }
+};
