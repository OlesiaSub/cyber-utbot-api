package org.cyber.utbot.api.utils.additions.fuzzing

import VulnerabilityArgumentsCheckWithDescription
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.toList
import kotlinx.coroutines.runBlocking
import org.cyber.utbot.api.CYBER_MOCK_ALWAYS_DEFAULT
import org.cyber.utbot.api.GenerateTestsSettings
import org.cyber.utbot.api.MOCK_ALWAYS_DEFAULT
import org.cyber.utbot.api.utils.*
import org.cyber.utbot.api.utils.additions.constraints.Constraints
import org.cyber.utbot.api.utils.annotations.CyberModify
import org.cyber.utbot.api.utils.overrides.fuzzing.cyberMutations
import org.cyber.utbot.api.utils.overrides.fuzzing.cyberRunJavaFuzzing
import org.cyber.utbot.api.utils.overrides.fuzzing.defaultValueProviders
import org.cyber.utbot.api.utils.viewers.UTBotViewers
import org.utbot.common.PathUtil
import org.utbot.common.PathUtil.toPath
import org.utbot.common.PathUtil.toURL
import org.utbot.common.filterWhen
import org.utbot.common.toPath
import org.utbot.engine.*
import org.utbot.framework.TestSelectionStrategyType
import org.utbot.framework.UtSettings
import org.utbot.framework.plugin.api.*
import org.utbot.framework.plugin.api.util.*
import org.utbot.framework.util.graph
import org.utbot.framework.util.isKnownImplicitlyDeclaredMethod
import org.utbot.framework.util.sootMethod
import org.utbot.fuzzer.collectConstantsForFuzzer
import org.utbot.fuzzing.*
import org.utbot.fuzzing.utils.Trie
import org.utbot.instrumentation.ConcreteExecutor
import org.utbot.instrumentation.instrumentation.execution.UtConcreteExecutionResult
import org.utbot.instrumentation.instrumentation.execution.UtExecutionInstrumentation
import soot.tagkit.ParamNamesTag
import java.io.File
import java.lang.Long.min
import java.lang.reflect.Method
import java.net.URLClassLoader
import java.nio.file.Path
import java.nio.file.Paths
import java.time.Instant.now

class TaintVulnerabilityChecksFuzzer : VulnerabilityChecksFuzzer {
    override fun generate(
        methodId: MethodId,
        parametersInfo: ParametersInfo?, // вероятно не нужна
        constraints: Constraints,
        description: String,
        methods: List<String>,
        taintedArgs: MutableSet<Pair<SymbolicValue, Int>>
    ): VulnerabilityArgumentsCheckWithDescription? {
        runBlocking {
            val deferredResult = async(Dispatchers.Default) {
                val settings = GenerateTestsSettings(
                    "C:/Users/lesya/uni2/UTBotJava/cyber-utbot-exploit-base/build/classes/java/main",
//            generationTimeout = 180_000,
                    codegenLanguage = CodegenLanguage.JAVA,
                    mockAlways = MOCK_ALWAYS_DEFAULT + CYBER_MOCK_ALWAYS_DEFAULT,
                    mockStrategy = MockStrategyApi.NO_MOCKS,
                    withUtSettings = {
                        UtSettings.useFuzzing = true; UtSettings.useDebugVisualization = true
                        UtSettings.testMinimizationStrategyType = TestSelectionStrategyType.DO_NOT_MINIMIZE_STRATEGY
                    },
                    utbotViewers = setOf(UTBotViewers.TERMINAL_STATISTIC_VIEWER),
                    vulnerabilityType = description,
                    vulnerabilityCheckBases = listOf("$UTBOT_DIR/cyber-utbot-exploit-base")
                )
                Configuration.vulnerabilityType = description
                taintedArgs?.let { Configuration.taintedArgs = taintedArgs.map { it.second } }
                (settings.classpath)?.let{ updateClassLoader(settings.classpath) } ?: throw Exception("classpath should be set")
                println("IN GEN")
                mapOf("org.cyber.base.Files" to "src/main/java/org/cyber/base/Files").toTestUnits().forEach { testUnit -> // todo знать на чем запускать
                    // maps method to a list of fuzzed arguments for each of its parameters, removers first as afaik it is not needed
                    val collected = runInside(testUnit.target, methods).removeFirst()
                    println(collected)
                }
            }
            deferredResult.await()
        }
        return null
    }

    private lateinit var classLoader: URLClassLoader

    private var classpath: String? = null
    private fun updateClassLoader(classpath: String) {
        if (this.classpath != classpath) {
            this.classpath = classpath
            val urls = classpath
                .split(File.pathSeparator)
                .map { uri ->
                    uri.toPath().toURL()
                }
                .toTypedArray()
            classLoader = URLClassLoader(urls)
        }
    }
    private fun updateClasspath(classpath: String, vulnerabilityCheckBases: List<String>): String { // todo??
        val baseClasspathes = vulnerabilityCheckBases.map {
            "$it${File.separator}$DEFAULT_BUILS_CLASSES_PATH"
        }
        return "$classpath${File.pathSeparator}${baseClasspathes.joinToString(separator = File.pathSeparator)}"
    }

    private val concreteExecutor =
        ConcreteExecutor(
            UtExecutionInstrumentation,
            "C:/Users/lesya/uni2/UTBotJava/cyber-utbot-exploit-base/build/classes/java/main",
        ).apply { this.classLoader = utContext.classLoader }
    private fun getWorkingDirectory(classFqn: String): Path? {
        val classRelativePath = PathUtil.classFqnToPath(classFqn) + ".class"
        val classAbsoluteURL = classLoader.getResource(classRelativePath) ?: return null
        val classAbsolutePath = PathUtil.replaceSeparator(classAbsoluteURL.toPath().toString())
            .removeSuffix(classRelativePath)
        return Paths.get(classAbsolutePath)
    }
    private fun runInside( targetClassFqn: TargetQualifiedName,
                           genMethods: List<String> = listOf()): MutableList<Pair<MethodId, List<List<String>>>> {
        val collected: MutableList<Pair<MethodId, List<List<String>>>> = mutableListOf()
        try {
            // utContext is used in `targetMethods`, `generate`, `generateTest`, `generateReport`
            withUtContext(UtContext(classLoader)) {
                val classIdUnderTest = ClassId(targetClassFqn)
                val targetMethods = classIdUnderTest.targetMethods()
                    .filterWhen(UtSettings.skipTestGenerationForSyntheticAndImplicitlyDeclaredMethods) {
                        !it.isSynthetic && !it.isKnownImplicitlyDeclaredMethod
                    }
                    .filter {
                        if (genMethods.isEmpty()) true
                        else genMethods.contains(it.name)
                    }
                    .filterNot { it.isAbstract }
                targetMethods.forEach {
                    var m: List<List<String>>
                    val l : MutableList<UtResult> = mutableListOf()
                    runBlocking {
                        fuzzing(it).toList(l)
                        m = cyberMutations.distinct()
                    }
                    collected.add(Pair(it, m))
                }
                if (targetMethods.isEmpty()) {
                    throw Exception("Nothing to process. No methods were provided")
                }
            }
        } catch (e: Exception) {}
        return collected
    }
    private fun ClassId.targetMethods(): List<MethodId> =
        allMethods.filter { it.classId == this }.toList()

    /**
     * Run fuzzing flow.
     *
     * @param until is used by fuzzer to cancel all tasks if the current time is over this value
     * @param transform provides model values for a method
     */
    @CyberModify("replace original java language fuzzing by cyber fuzzing")
    fun fuzzing(methodUnderTest: MethodId, until: Long = Long.MAX_VALUE, transform: (JavaValueProvider) -> JavaValueProvider = { it }) =
        flow<UtResult> {
            println("fuzzing")
            val isFuzzable = methodUnderTest.parameters.all { classId ->
                classId != Method::class.java.id && // causes the instrumented process crash at invocation
                        classId != Class::class.java.id  // causes java.lang.IllegalAccessException: java.lang.Class at sun.misc.Unsafe.allocateInstance(Native Method)
            }
            val hasMethodUnderTestParametersToFuzz = methodUnderTest.parameters.isNotEmpty()
            if (!isFuzzable || !hasMethodUnderTestParametersToFuzz && methodUnderTest.isStatic) {
                // Currently, fuzzer doesn't work with static methods with empty parameters
                return@flow
            }
//            val errorStackTraceTracker = Trie(StackTraceElement::toString)
//            var attempts = 0
            val attemptsLimit = UtSettings.fuzzingMaxAttempts
            var attempts = 0
            val graph = methodUnderTest.sootMethod.jimpleBody().graph()
            val names = graph.body.method.tags.filterIsInstance<ParamNamesTag>().firstOrNull()?.names ?: emptyList()
            var testEmittedByFuzzer = 0
            cyberRunJavaFuzzing(
                defaultIdGenerator,
                methodUnderTest,
                collectConstantsForFuzzer(graph),
                names,
                listOf(transform(ValueProvider.of(defaultValueProviders(defaultIdGenerator))))
                // todo fst info here
            ) { thisInstance, descr, values ->
//                println("values: ")
//                values.forEach { println(it.summary) }
                if (thisInstance?.model is UtNullModel) {
                    // We should not try to run concretely any models with null-this.
                    // But fuzzer does generate such values, because it can fail to generate any "good" values.
                    return@cyberRunJavaFuzzing BaseFeedback(Trie.emptyNode(), Control.PASS)
                }

                val diff = until - System.currentTimeMillis() + 1000
                val thresholdMillisForFuzzingOperation = 0 // may be better use 10-20 millis as it might not be possible
                // to concretely execute that values because request to instrumentation process involves
                // 1. serializing/deserializing it with kryo
                // 2. sending over rd
                // 3. concrete execution itself
                // 4. analyzing concrete result
                if (diff <= thresholdMillisForFuzzingOperation || attempts > attemptsLimit) {
                    attempts += 1
                    println("diff: $diff, threshhold: $thresholdMillisForFuzzingOperation")
//                    logger.info { "Fuzzing overtime: $methodUnderTest" }
//                    logger.info { "Test created by fuzzer: $testEmittedByFuzzer" }
                    return@cyberRunJavaFuzzing BaseFeedback(result = Trie.emptyNode(), control = Control.STOP)
                }

                val initialEnvironmentModels = EnvironmentModels(thisInstance?.model, values.map { it.model }, mapOf())

                val concreteExecutionResult: UtConcreteExecutionResult? = try {
                    val timeoutMillis = min(UtSettings.concreteExecutionDefaultTimeoutInInstrumentedProcessMillis, diff)
                    concreteExecutor.executeConcretely(
                        methodUnderTest,
                        initialEnvironmentModels,
                        listOf(),
                        timeoutMillis
                    )
                } catch (e: Throwable) {
                    emit(UtError("Default concrete execution failed", e)); null
                }

                // in case an exception occurred from the concrete execution
                concreteExecutionResult ?: return@cyberRunJavaFuzzing BaseFeedback(
                    result = Trie.emptyNode(),
                    control = Control.PASS
                )
                println("concrete result: ${concreteExecutionResult.result}")

                if (concreteExecutionResult.violatesUtMockAssumption()) {
//                    logger.debug { "Generated test case by fuzzer violates the UtMock assumption: $concreteExecutionResult" }
                    return@cyberRunJavaFuzzing BaseFeedback(result = Trie.emptyNode(), control = Control.PASS)
                }

                val coveredInstructions = concreteExecutionResult.coverage.coveredInstructions
                val trieNode: Trie.Node<Instruction>?
                if (coveredInstructions.isNotEmpty()) {
                    trieNode = descr.tracer.add(coveredInstructions)
                    if (trieNode.count > 10) {
                        if (++attempts >= attemptsLimit) {
                            println("in att")
                            return@cyberRunJavaFuzzing BaseFeedback(result = Trie.emptyNode(), control = Control.STOP)
                        }
                        return@cyberRunJavaFuzzing BaseFeedback(result = trieNode, control = Control.CONTINUE)
                    }
                } else {
//                    logger.error { "Coverage is empty for $methodUnderTest with $values" }
                    val result = concreteExecutionResult.result
                    if (result is UtSandboxFailure) {
                        val stackTraceElements = result.exception.stackTrace.reversed()
//                        if (errorStackTraceTracker.add(stackTraceElements).count > 1) {
//                            return@cyberRunJavaFuzzing BaseFeedback(result = Trie.emptyNode(), control = Control.PASS)
//                        }
                    }
                }
                if (values.size > 2)
                    println("EMITss ${values[0].summary} ${values[1].summary} ${values[2].summary}")
                else if (values.size > 1)
                    println("EMITs ${values[0].summary} ${values[1].summary}")
                else println("EMIT ${values[0].summary}")
//                emit(
//                    UtFuzzedExecution(
//                        stateBefore = initialEnvironmentModels,
//                        stateAfter = concreteExecutionResult.stateAfter,
//                        result = concreteExecutionResult.result,
//                        coverage = concreteExecutionResult.coverage,
//                        fuzzingValues = values,
//                        fuzzedMethodDescription = descr.description
//                    )
//                )

                testEmittedByFuzzer++
                BaseFeedback(result = Trie.emptyNode(), control = Control.CONTINUE)
            }
            println("AAAAA STOP")

    }

}