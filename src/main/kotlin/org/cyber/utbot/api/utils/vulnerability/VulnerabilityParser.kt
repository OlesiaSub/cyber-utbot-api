package org.cyber.utbot.api.utils.vulnerability

import java.io.File
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import org.cyber.utbot.api.abstraction.JsonVulnerability
import org.cyber.utbot.api.abstraction.VulnerabilityFun
import org.cyber.utbot.api.abstraction.VulnerabilityInfo
import org.cyber.utbot.api.exceptions.CyberException
import org.utbot.engine.SymbolicValue
import org.utbot.engine.pc.UtBoolExpression

class VulnerabilityParser {
    private val gson = Gson()
    private val argumentsType = object : TypeToken<List<List<Any>>>() {}.type
    private val constraintsType = object : TypeToken<List<Any>>() {}.type
    private val vulnerabilityFunCreator = VulnerabilityFunCreator()

    private fun File.read() = bufferedReader().use { it.readText() }

    fun parseVulnerabilityDirectory(directory: String): MutableMap<Pair<String?, String>, MutableList<VulnerabilityInfo>> {
        val vulnerabilityInfos = mutableMapOf<Pair<String?, String>, MutableList<VulnerabilityInfo>>()
        File(directory).walk().forEach { file ->
            if (file.isDirectory) return@forEach
            val vulnerability = gson.fromJson(file.read(), JsonVulnerability::class.java)
            assert(vulnerability.arguments == null || vulnerability.constraints == null) {
                "Json vulnerability exception: should be only one way to set a condition for a function"
            }
            vulnerability.apply {
                vulnerabilityInfos.getOrPut(fullyQualified to function) { mutableListOf() }.add(
                    arguments?.run {
                        VulnerabilityInfo(description, this, VulnerabilityCreationMode.ARGUMENTS)
                    } ?: constraints?.run {
                        VulnerabilityInfo(description, this, VulnerabilityCreationMode.CONSTRAINTS)
                    } ?: throw CyberException("Json vulnerability exception: arguments and constraints not set")
                )
            }
        }
        return vulnerabilityInfos
    }

    private fun parseArgumentsVulnerability(paths: List<String>):  (List<SymbolicValue>) -> Set<UtBoolExpression> =
        vulnerabilityFunCreator.funByArguments(paths.map {
            gson.fromJson<List<List<Any>>>(File(it).read(), argumentsType)
        }.flatten())

    private fun parseConstraintsVulnerability(paths: List<String>):  (List<SymbolicValue>) -> Set<UtBoolExpression> =
        vulnerabilityFunCreator.funByConstraints(paths.map {
            gson.fromJson<List<Any>>(File(it).read(), constraintsType)
        }.flatten())

    fun parseVulnerability(vulnerabilityInfo: VulnerabilityInfo): VulnerabilityFun {
        val func = when(vulnerabilityInfo.mode) {
            VulnerabilityCreationMode.ARGUMENTS -> parseArgumentsVulnerability(vulnerabilityInfo.paths)
            VulnerabilityCreationMode.CONSTRAINTS -> parseConstraintsVulnerability(vulnerabilityInfo.paths)
        }
        return VulnerabilityFun(func = func, description = vulnerabilityInfo.description)
    }
}
