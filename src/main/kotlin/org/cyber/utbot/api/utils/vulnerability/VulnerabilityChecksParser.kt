package org.cyber.utbot.api.utils.vulnerability

import java.io.File
import com.google.gson.Gson
import org.cyber.utbot.api.abstraction.JsonVulnerability
import org.cyber.utbot.api.abstraction.JsonVulnerabilityArgumentsCheck
import org.cyber.utbot.api.abstraction.VulnerabilityCheck
import org.cyber.utbot.api.abstraction.VulnerabilityCheckInfo
import org.cyber.utbot.api.abstraction.extraChecks.AnyVulnerabilityCheck
import org.cyber.utbot.api.abstraction.extraChecks.ArgumentsVulnerabilityCheck
import org.cyber.utbot.api.abstraction.extraChecks.FunctionsVulnerabilityCheck
import org.cyber.utbot.api.exceptions.CyberException
import org.cyber.utbot.api.utils.FunctionId
import org.cyber.utbot.api.utils.vulnerability.parsers.ArgumentsVulnerabilityChecksCreator
import org.cyber.utbot.api.utils.vulnerability.parsers.FunctionsVulnerabilityChecksCreator

class VulnerabilityChecksParser {
    private val gson = Gson()

    private fun File.read() = bufferedReader().use { it.readText() }

    fun parseVulnerabilityChecksDirectory(directory: String): MutableMap<Pair<String, String>, MutableList<VulnerabilityCheckInfo>> {
        val vulnerabilityCheckInfos = mutableMapOf<FunctionId, MutableList<VulnerabilityCheckInfo>>()
        File(directory).walk().forEach { file ->
            if (file.isDirectory) return@forEach
            val vulnerability = gson.fromJson(file.read(), JsonVulnerability::class.java)
            assert(listOf(vulnerability.functions != null, vulnerability.arguments != null, vulnerability.constraints != null).count { it } == 1) {
                "Json vulnerability exception: should be only one way to set a condition for a function"
            }
            vulnerability.apply {
                vulnerabilityCheckInfos.getOrPut(fullyQualified to function) { mutableListOf() }.add(
                    when {
                        functions != null -> VulnerabilityCheckInfo(description, functions, VulnerabilityCheckCreationMode.FUNCTIONS)
                        arguments != null -> VulnerabilityCheckInfo(description, arguments, VulnerabilityCheckCreationMode.ARGUMENTS)
                        constraints != null -> VulnerabilityCheckInfo(description, constraints, VulnerabilityCheckCreationMode.CONSTRAINTS)
                        else -> throw CyberException("Json vulnerability exception: functions, arguments and constraints not set")
                    }
                )
            }
        }
        return vulnerabilityCheckInfos
    }

    fun parseAnyVulnerabilityCheck(checks: List<AnyVulnerabilityCheck>, description: String): VulnerabilityCheck {
        val functions = mutableListOf<FunctionId>()
        val arguments = mutableListOf<JsonVulnerabilityArgumentsCheck>()
        checks.forEach {
            when (it) {
                is FunctionsVulnerabilityCheck -> functions.addAll(it.functions)
                is ArgumentsVulnerabilityCheck -> arguments.add(JsonVulnerabilityArgumentsCheck(it.signature, it.arguments))
            }
        }
        val functionIds: List<FunctionId> = FunctionsVulnerabilityChecksCreator.check(functions) + ArgumentsVulnerabilityChecksCreator.check(arguments)
        return VulnerabilityCheck(functionIds, description)
    }

    fun parseVulnerabilityCheckInfo(vulnerabilityCheckInfo: VulnerabilityCheckInfo) =
        vulnerabilityCheckInfo.mode.creator.parseVulnerabilityCheckInfo(vulnerabilityCheckInfo)
}
