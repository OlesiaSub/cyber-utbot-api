package org.cyber.utbot.api.utils.vulnerability

import java.io.File
import com.google.gson.Gson
import org.cyber.utbot.api.abstraction.JsonVulnerability
import org.cyber.utbot.api.abstraction.JsonVulnerabilityArgumentsCheck
import org.cyber.utbot.api.abstraction.VulnerabilityCheck
import org.cyber.utbot.api.abstraction.VulnerabilityCheckInfo
import org.cyber.utbot.api.abstraction.extraChecks.AnyVulnerabilityCheck
import org.cyber.utbot.api.abstraction.extraChecks.ArgumentsVulnerabilityCheck
import org.cyber.utbot.api.abstraction.extraChecks.FunctionsVulnerabilityCheck
import org.cyber.utbot.api.exceptions.CyberException
import org.cyber.utbot.api.utils.FunctionId
import org.cyber.utbot.api.utils.vulnerability.parsers.ArgumentsVulnerabilityChecksCreator
import org.cyber.utbot.api.utils.vulnerability.parsers.FunctionsVulnerabilityChecksCreator
import org.utbot.common.isUnix

class VulnerabilityChecksParser(private val checksAnalysisSuffix: String, private val checksSuffix: String) {
    private val gson = Gson()
    private val osSuffix = if (isUnix) "unix" else "windows"
    private val pathsMap = mutableMapOf<Pair<String, String>, String>()

    private fun File.read() = bufferedReader().use { it.readText() }

    private fun fixPaths(paths: List<String>, directory: String): List<String> {
        fun withOsSubPath(path: String): String {
            val prefix = path.substringBeforeLast("/")
            val suffix = path.substringAfterLast("/")
            return "$prefix/$osSuffix/$suffix"
        }

        return paths.map { path ->
            pathsMap[path to directory] ?: run {
                var checkPath = "$directory/$checksSuffix/$path"
                if (!File(checkPath).exists()) {
                    val checkPathWithOs = withOsSubPath(checkPath)
                    if (!File(checkPathWithOs).exists()) {
                        throw CyberException("Analysis $directory/$checksAnalysisSuffix. Paths not exist: $checkPath, $checkPathWithOs")
                    }
                    checkPath = checkPathWithOs
                }
                checkPath.also { pathsMap[path to directory] = it }
            }
        }
    }

    fun parseVulnerabilityChecksDirectory(directory: String): MutableMap<Pair<String, String>, MutableList<VulnerabilityCheckInfo>> {
        val vulnerabilityCheckInfos = mutableMapOf<FunctionId, MutableList<VulnerabilityCheckInfo>>()
        File("$directory/$checksAnalysisSuffix").walk().forEach { file ->
            if (file.isDirectory) return@forEach
            val vulnerability = gson.fromJson(file.read(), JsonVulnerability::class.java)
            assert(listOf(vulnerability.functions != null, vulnerability.arguments != null, vulnerability.constraints != null).count { it } == 1) {
                "Json vulnerability exception: should be only one way to set a condition for a function"
            }
            vulnerability.apply {
                vulnerabilityCheckInfos.getOrPut(fullyQualified to function) { mutableListOf() }.add(
                    when {
                        functions != null -> VulnerabilityCheckInfo(description, fixPaths(functions, directory), VulnerabilityCheckCreationMode.FUNCTIONS)
                        arguments != null -> VulnerabilityCheckInfo(description, fixPaths(arguments, directory), VulnerabilityCheckCreationMode.ARGUMENTS)
                        constraints != null -> VulnerabilityCheckInfo(description, fixPaths(constraints, directory), VulnerabilityCheckCreationMode.CONSTRAINTS)
                        else -> throw CyberException("Json vulnerability exception: functions, arguments and constraints not set")
                    }
                )
            }
        }
        return vulnerabilityCheckInfos
    }

    fun parseAnyVulnerabilityCheck(checks: List<AnyVulnerabilityCheck>, description: String): VulnerabilityCheck {
        val functions = mutableListOf<FunctionId>()
        val arguments = mutableListOf<JsonVulnerabilityArgumentsCheck>()
        checks.forEach {
            when (it) {
                is FunctionsVulnerabilityCheck -> functions.addAll(it.functions)
                is ArgumentsVulnerabilityCheck -> arguments.add(JsonVulnerabilityArgumentsCheck(it.signature, it.arguments))
            }
        }
        val functionIds: List<FunctionId> = FunctionsVulnerabilityChecksCreator.check(functions) + ArgumentsVulnerabilityChecksCreator.check(arguments)
        return VulnerabilityCheck(functionIds, description)
    }

    fun parseVulnerabilityCheckInfo(vulnerabilityCheckInfo: VulnerabilityCheckInfo) =
        vulnerabilityCheckInfo.mode.creator.parseVulnerabilityCheckInfo(vulnerabilityCheckInfo)
}
