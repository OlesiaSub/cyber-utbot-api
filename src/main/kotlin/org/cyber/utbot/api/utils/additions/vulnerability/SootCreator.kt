package org.cyber.utbot.api.utils.additions.vulnerability

import org.cyber.utbot.api.abstraction.VulnerabilityCheck
import org.cyber.utbot.api.utils.ASSERT_CLASS_NAME
import org.cyber.utbot.api.utils.ASSERT_FUNCTION_NAME
import org.cyber.utbot.api.utils.VULNERABILITY_CHECKS_CLASS_NAME
import org.utbot.engine.*
import org.utbot.engine.toInvokeStmt
import org.utbot.engine.types.STRING_TYPE
import soot.*
import soot.Unit
import soot.jimple.EqExpr
import soot.jimple.Jimple
import soot.jimple.StringConstant
import soot.jimple.internal.JimpleLocal

private val sootClassVulnerabilityChecks = Scene.v().getSootClass(VULNERABILITY_CHECKS_CLASS_NAME)


internal fun eqExpr(left: Value, right: Value): EqExpr = Jimple.v().newEqExpr(left, right)


fun decorateVulnerabilityFunction(target: InvocationTarget, methodName: String, checks: List<VulnerabilityCheck>): SootMethod {     // TODO check static
    // check if it is already defined
    val cachedMethod = sootClassVulnerabilityChecks.getMethodByNameUnsafe(methodName)
    if (cachedMethod != null) {
        return cachedMethod
    }

    // checks
    val targetInstanceType = target.instance!!.type as RefType  // TODO check other cases

    // helpers
    var objectCounter = 0
    val int1 = intConstant(1)
    val units = mutableListOf<Unit>()
    val assertUnits = mutableListOf<Unit>()     // at the end of units
    val locals = mutableSetOf<JimpleLocal>()

    // types
    val booleanType = BooleanType.v()
    val paramTypes = target.method.parameterTypes
    val stringListType = listOf(STRING_TYPE)

    // initialize parameter locals
    val parameterLocals = paramTypes.map {
        JimpleLocal("r${objectCounter++}", it)
    }
    locals += parameterLocals

    val parameterRefs = paramTypes.mapIndexed { idx, type  -> parameterRef(type, idx) }
    val identityStmts = parameterLocals.zip(parameterRefs) { local, ref -> identityStmt(local, ref) }
    units += identityStmts


    // assert part 1
    val assertSootClass = Scene.v().getSootClass(ASSERT_CLASS_NAME)

    val assertNewSootClassExpr = newNewExpr(assertSootClass.type)
    val assertSootClassInstance = JimpleLocal("\$r${objectCounter++}", assertSootClass.type)
    locals += assertSootClassInstance

    // checks
    checks.forEach { vulnerabilityCheck ->
        // assert part 2
        val assertAssignInstanceStmt = assignStmt(assertSootClassInstance, assertNewSootClassExpr)
        assertUnits += assertAssignInstanceStmt

        val assertInitSootMethod = assertSootClass.getMethod("<init>", emptyList())
        val assertInitSootExpr = assertInitSootMethod.toSpecialInvokeExpr(assertSootClassInstance)
        assertUnits += assertInitSootExpr.toInvokeStmt()

        val assertSootMethod = assertSootClass.getMethod(ASSERT_FUNCTION_NAME, stringListType)
        val assertInvoke = assertSootMethod.toVirtualInvokeExpr(assertSootClassInstance, StringConstant.v(vulnerabilityCheck.description))
        assertUnits += assertInvoke.toInvokeStmt()
        // assert part 2 end

        vulnerabilityCheck.functionIds.forEach { (checkClassName, checkFunctionName) ->
            val checkSootClass = Scene.v().getSootClass(checkClassName)

            val checkNewSootClassExpr = newNewExpr(checkSootClass.type)
            val checkClassInstance = JimpleLocal("\$r${objectCounter++}", checkSootClass.type)
            locals += checkClassInstance
            units += assignStmt(checkClassInstance, checkNewSootClassExpr)

            val checkInitSootMethod = checkSootClass.getMethod("<init>", emptyList())    // TODO (no constructor???)
            val checkInitSootExpr = checkInitSootMethod.toSpecialInvokeExpr(checkClassInstance)
            units += checkInitSootExpr.toInvokeStmt()

            val checkSootMethod = checkSootClass.getMethod(checkFunctionName, paramTypes, booleanType)
            val checkResult = JimpleLocal("\$r${objectCounter++}", booleanType)
            locals += checkResult

            val checkInvoke = checkSootMethod.toVirtualInvokeExpr(checkClassInstance, *parameterLocals.toTypedArray())
            val checkAssignStmt = assignStmt(checkResult, checkInvoke)
            units += checkAssignStmt

            val checkCondition = eqExpr(checkResult, int1)

            units += ifStmt(checkCondition, assertAssignInstanceStmt)
        }
    }

    // target
    val targetNewSootClassExpr = newNewExpr(targetInstanceType)
    val targetClassInstance = JimpleLocal("\$r${objectCounter++}", targetInstanceType)
    locals += targetClassInstance
    val targetAssignInstanceStmt = assignStmt(targetClassInstance, targetNewSootClassExpr)

    val targetResult = JimpleLocal("\$r${objectCounter++}", target.method.returnType)
    locals += targetResult

    val targetInvoke = target.method.toVirtualInvokeExpr(targetClassInstance, *parameterLocals.toTypedArray())
    val targetAssignStmt = assignStmt(targetResult, targetInvoke)

    val returnStmt = returnStatement(targetResult)

    units += targetAssignInstanceStmt
    units += targetAssignStmt
    units += returnStmt

    // update units with assertUnits
    units += assertUnits

    val body = units.toGraphBody()
    body.locals.addAll(locals)

    return createSootMethod(methodName, paramTypes, booleanType, sootClassVulnerabilityChecks, body)
}
