package org.cyber.utbot.api.utils.additions.vulnerability

import kotlinx.coroutines.runBlocking
import org.cyber.utbot.api.CYBER_MOCK_ALWAYS_DEFAULT
import org.cyber.utbot.api.GenerateTestsSettings
import org.cyber.utbot.api.MOCK_ALWAYS_DEFAULT
import org.cyber.utbot.api.TestGenerator
import org.cyber.utbot.api.abstraction.JsonVulnerabilityArgumentsCheck
import org.cyber.utbot.api.abstraction.VulnerabilityCheck
import org.cyber.utbot.api.abstraction.utils.ArgType
import org.cyber.utbot.api.exceptions.CyberException
import org.cyber.utbot.api.utils.UTBOT_DIR
import org.cyber.utbot.api.utils.toTestUnits
import org.cyber.utbot.api.utils.viewers.UTBotViewers
import org.utbot.common.PathUtil.toPath
import org.utbot.engine.*
import org.utbot.engine.toInvokeStmt
import org.utbot.framework.TestSelectionStrategyType
import org.utbot.framework.UtSettings
import org.utbot.framework.plugin.api.CodegenLanguage
import org.utbot.framework.plugin.api.MockStrategyApi
import org.utbot.fuzzing.Configuration
import soot.*
import soot.Unit
import soot.jimple.*
import soot.jimple.internal.JimpleLocal
import java.nio.file.Files


fun decorateVulnerabilityFunction(
    target: InvocationTarget,
    methodName: String,
    checks: List<VulnerabilityCheck>,
    engine: UtBotSymbolicEngine? = null,
    taintedArgs: MutableSet<Pair<SymbolicValue, Int>>? = null
): SootMethod {
    // check if it is already defined
    val cachedMethod = sootClassVulnerabilityChecks.getMethodByNameUnsafe(methodName)
    if (cachedMethod != null) {
        return cachedMethod
    }

    // helpers
    var objectCounter = 0
    val units = mutableListOf<Unit>()
    val assertUnits = mutableListOf<Unit>()     // at the end of units
    val locals = mutableSetOf<JimpleLocal>()

    // types
    val booleanType = BooleanType.v()
    val paramTypes = target.method.parameterTypes

    // initialize parameter locals
    val parameterLocals = paramTypes.map {
        JimpleLocal("r${objectCounter++}", it)
    }
    locals += parameterLocals

    val parameterRefs = paramTypes.mapIndexed { idx, type -> parameterRef(type, idx) }
    val identityStmts = parameterLocals.zip(parameterRefs) { local, ref -> identityStmt(local, ref) }
    units += identityStmts

    var vulnerabilityType = ""
    val methods = mutableListOf<String>()
    // checks
    checks.forEach { vulnerabilityCheck ->
        // assert
        val assertInvoke = assertSootMethod.toStaticInvokeExpr(StringConstant.v(vulnerabilityCheck.description))
        val assertInvokeStmt = assertInvoke.toInvokeStmt()
        assertUnits += assertInvokeStmt
        // assert end

        vulnerabilityCheck.functionIds.forEach { (checkClassName, checkFunctionName) ->
            val checkSootClass = Scene.v().getSootClass(checkClassName)
            vulnerabilityCheck.description?.let { vulnerabilityType = it }

            val checkSootMethod = checkSootClass.getMethodUnsafe(checkFunctionName, paramTypes, booleanType)
            if (checkSootMethod == null) return@forEach
            methods.add(checkSootMethod.name)

            val checkInvoke = if (checkSootMethod.isStatic) {
                checkSootMethod.toStaticInvokeExpr(*parameterLocals.toTypedArray())
            } else {
                val checkNewSootClassExpr = newNewExpr(checkSootClass.type)
                val checkClassInstance = JimpleLocal("\$r${objectCounter++}", checkSootClass.type)
                locals += checkClassInstance
                units += assignStmt(checkClassInstance, checkNewSootClassExpr)

                val checkInitSootMethod = checkSootClass.getMethod("<init>", emptyList())    // TODO (no constructor???)
                val checkInitSootExpr = checkInitSootMethod.toSpecialInvokeExpr(checkClassInstance)
                units += checkInitSootExpr.toInvokeStmt()

                checkSootMethod.toVirtualInvokeExpr(checkClassInstance, *parameterLocals.toTypedArray())
            }

            val checkResult = JimpleLocal("\$r${objectCounter++}", booleanType)
            locals += checkResult
            units += assignStmt(checkResult, checkInvoke)

            val checkCondition = eqExpr(checkResult, int1)
            units += ifStmt(checkCondition, assertInvokeStmt)
        }
    }

    // target   // TODO dynamic invoke
    val targetInvoke = if (target.method.isStatic) {
        target.method.toStaticInvokeExpr(*parameterLocals.toTypedArray())
    } else {
        val targetInstanceType = target.instance!!.type as RefType

        val targetNewSootClassExpr = newNewExpr(targetInstanceType)
        val targetClassInstance = JimpleLocal("\$r${objectCounter++}", targetInstanceType)
        locals += targetClassInstance

        val targetAssignInstanceStmt = assignStmt(targetClassInstance, targetNewSootClassExpr)
        units += targetAssignInstanceStmt

        if (target.method.isConstructor) {
            target.method.toSpecialInvokeExpr(targetClassInstance, *parameterLocals.toTypedArray())
        } else {
            target.method.toVirtualInvokeExpr(targetClassInstance, *parameterLocals.toTypedArray())
        }
    }

    val targetResult = JimpleLocal("\$r${objectCounter++}", target.method.returnType)
    locals += targetResult

    units += assignStmt(targetResult, targetInvoke)

    units += returnStatement(targetResult)

    // update units with assertUnits
    units += assertUnits

    val body = units.toGraphBody()
    body.locals.addAll(locals)

    val sootMethod = createSootMethod(methodName, paramTypes, booleanType, sootClassVulnerabilityChecks, body)

    println("here!!")
    runBlocking { // TODO(add settings for it)
        launchFuzzing(vulnerabilityType, methods, taintedArgs)
    }

    return sootMethod
}

fun launchFuzzing(
    vulnerabilityType: String,
    methods: MutableList<String>,
    taintedArgs: MutableSet<Pair<SymbolicValue, Int>>? = null
) {
    val settings = GenerateTestsSettings(
        "C:/Users/lesya/uni2/UTBotJava/cyber-utbot-api/build/classes/java/main",
        codegenLanguage = CodegenLanguage.JAVA,
        mockAlways = MOCK_ALWAYS_DEFAULT + CYBER_MOCK_ALWAYS_DEFAULT,
        mockStrategy = MockStrategyApi.NO_MOCKS,
        withUtSettings = {
            UtSettings.useFuzzing = true; UtSettings.useDebugVisualization =
            true; UtSettings.testMinimizationStrategyType = TestSelectionStrategyType.DO_NOT_MINIMIZE_STRATEGY;
        },
        utbotViewers = setOf(UTBotViewers.TERMINAL_STATISTIC_VIEWER),
        vulnerabilityCheckDirectories = listOf("$UTBOT_DIR/cyber-utbot-exploit-base/src/base"),
        vulnerabilityType = vulnerabilityType
    )
    Configuration.vulnerabilityType = vulnerabilityType
    taintedArgs?.let { Configuration.taintedArgs = taintedArgs.map { it.second } }
    val generator = TestGenerator(settings)
    val (tests, info) = generator.run(mapOf("org.cyber.exploitBase.Files" to "src/main/java/org/cyber/exploitBase/Files").toTestUnits(), genMethods = methods)
    tests.forEach { nameAndTest ->
        Files.write(
            "src/test/java/org/example/${nameAndTest.key.takeLastWhile { it != '.' }}TestFuzz.java".toPath(),
            listOf(nameAndTest.value)
        )
    }
}

fun createConstraintsFunction(methodName: String, argumentsList: JsonVulnerabilityArgumentsCheck): SootMethod {
    val cachedMethod = sootClassVulnerabilityChecksFunctions.getMethodByNameUnsafe(methodName)
    if (cachedMethod != null) {
        return cachedMethod
    }

    // helpers
    var objectCounter = 0
    val units = mutableListOf<Unit>()
    val locals = mutableSetOf<JimpleLocal>()

    // types
    val booleanType = BooleanType.v()
    val wrapParamTypes = argumentsList.signature.map { ArgType.fromString(it) }
    val paramTypes = wrapParamTypes.map { it.type }

    // initialize parameter locals
    val parameterLocals = paramTypes.map {
        JimpleLocal("r${objectCounter++}", it)
    }
    locals += parameterLocals

    val parameterRefs = paramTypes.mapIndexed { idx, type -> parameterRef(type, idx) }
    val identityStmts = parameterLocals.zip(parameterRefs) { local, ref -> identityStmt(local, ref) }
    units += identityStmts


    //
    val constraintsParts = argumentsList.arguments.mapNotNull { args ->
        if (args.size != wrapParamTypes.size) throw CyberException("wrong count arguments: ${args.size} != ${wrapParamTypes.size} ($args, $wrapParamTypes)")
        val valuesWithTypes =
            args.zip(wrapParamTypes).map { (arg, type) -> if (arg is List<*>) null else type.const(arg) to type }
        val constraints = (parameterLocals.zip(valuesWithTypes).mapNotNull {
            it.second?.let { valueWithType ->
                val eqInvoke = equals(it.first, valueWithType.first, valueWithType.second)
                val eqResult = JimpleLocal("\$r${objectCounter++}", booleanType)
                locals += eqResult
                units += assignStmt(eqResult, eqInvoke)
                eqResult
            }
        })
        when (constraints.size) {
            0 -> null
            1 -> constraints.first()
            else -> {
                var and = Jimple.v().newAndExpr(constraints[0], constraints[1])
                var localResultAnd = JimpleLocal("\$r${objectCounter++}", booleanType)
                locals += localResultAnd
                units += assignStmt(localResultAnd, and)
                constraints.drop(2).forEach {
                    and = Jimple.v().newAndExpr(localResultAnd, it)
                    localResultAnd = JimpleLocal("\$r${objectCounter++}", booleanType)
                    locals += localResultAnd
                    units += assignStmt(localResultAnd, and)
                }
                localResultAnd
            }
        }
    }
    val resultLocal = when (constraintsParts.size) {
        0 -> {
            val resultLocal = JimpleLocal("\$r${objectCounter++}", booleanType)
            locals += resultLocal
            units += assignStmt(resultLocal, int0)
            resultLocal
        }

        1 -> constraintsParts.first()
        else -> {
            var or = Jimple.v().newOrExpr(constraintsParts[0], constraintsParts[1])
            var localResultOr = JimpleLocal("\$r${objectCounter++}", booleanType)
            locals += localResultOr
            units += assignStmt(localResultOr, or)
            constraintsParts.drop(2).forEach {
                or = Jimple.v().newOrExpr(localResultOr, it)
                localResultOr = JimpleLocal("\$r${objectCounter++}", booleanType)
                locals += localResultOr
                units += assignStmt(localResultOr, or)
            }
            localResultOr
        }
    }
    units += returnStatement(resultLocal)

    val body = units.toGraphBody()
    body.locals.addAll(locals)

    return createSootMethod(methodName, paramTypes, booleanType, sootClassVulnerabilityChecksFunctions, body)
}
