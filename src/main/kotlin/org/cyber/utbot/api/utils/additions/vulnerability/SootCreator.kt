package org.cyber.utbot.api.utils.additions.vulnerability

import org.cyber.utbot.api.abstraction.VulnerabilityCheck
import org.utbot.engine.*
import org.utbot.engine.toInvokeStmt
import org.utbot.engine.types.STRING_TYPE
import soot.*
import soot.Unit
import soot.jimple.*
import soot.jimple.internal.JimpleLocal


fun decorateVulnerabilityFunction(target: InvocationTarget, methodName: String, checks: List<VulnerabilityCheck>): SootMethod {
    // check if it is already defined
    val cachedMethod = sootClassVulnerabilityChecks.getMethodByNameUnsafe(methodName)
    if (cachedMethod != null) {
        return cachedMethod
    }

    // helpers
    var objectCounter = 0
    val int1 = intConstant(1)
    val units = mutableListOf<Unit>()
    val assertUnits = mutableListOf<Unit>()     // at the end of units
    val locals = mutableSetOf<JimpleLocal>()

    // types
    val booleanType = BooleanType.v()
    val paramTypes = target.method.parameterTypes

    // initialize parameter locals
    val parameterLocals = paramTypes.map {
        JimpleLocal("r${objectCounter++}", it)
    }
    locals += parameterLocals

    val parameterRefs = paramTypes.mapIndexed { idx, type  -> parameterRef(type, idx) }
    val identityStmts = parameterLocals.zip(parameterRefs) { local, ref -> identityStmt(local, ref) }
    units += identityStmts


    // checks
    checks.forEach { vulnerabilityCheck ->
        // assert
        val assertInvoke = assertSootMethod.toStaticInvokeExpr(StringConstant.v(vulnerabilityCheck.description))
        val assertInvokeStmt = assertInvoke.toInvokeStmt()
        assertUnits += assertInvokeStmt
        // assert end

        vulnerabilityCheck.functionIds.forEach { (checkClassName, checkFunctionName) ->
            val checkSootClass = Scene.v().getSootClass(checkClassName)

            val checkSootMethod = checkSootClass.getMethod(checkFunctionName, paramTypes, booleanType)

            val checkInvoke = if (checkSootMethod.isStatic) {
                checkSootMethod.toStaticInvokeExpr(*parameterLocals.toTypedArray())
            } else {
                val checkNewSootClassExpr = newNewExpr(checkSootClass.type)
                val checkClassInstance = JimpleLocal("\$r${objectCounter++}", checkSootClass.type)
                locals += checkClassInstance
                units += assignStmt(checkClassInstance, checkNewSootClassExpr)

                val checkInitSootMethod = checkSootClass.getMethod("<init>", emptyList())    // TODO (no constructor???)
                val checkInitSootExpr = checkInitSootMethod.toSpecialInvokeExpr(checkClassInstance)
                units += checkInitSootExpr.toInvokeStmt()

                checkSootMethod.toVirtualInvokeExpr(checkClassInstance, *parameterLocals.toTypedArray())
            }

            val checkResult = JimpleLocal("\$r${objectCounter++}", booleanType)
            locals += checkResult

            val checkAssignStmt = assignStmt(checkResult, checkInvoke)
            units += checkAssignStmt

            val checkCondition = eqExpr(checkResult, int1)

            units += ifStmt(checkCondition, assertInvokeStmt)
        }
    }

    // target
    val targetInvoke = if (target.method.isStatic) {
        target.method.toStaticInvokeExpr(*parameterLocals.toTypedArray())
    } else {
        val targetInstanceType = target.instance!!.type as RefType

        val targetNewSootClassExpr = newNewExpr(targetInstanceType)
        val targetClassInstance = JimpleLocal("\$r${objectCounter++}", targetInstanceType)
        locals += targetClassInstance

        val targetAssignInstanceStmt = assignStmt(targetClassInstance, targetNewSootClassExpr)
        units += targetAssignInstanceStmt

        target.method.toVirtualInvokeExpr(targetClassInstance, *parameterLocals.toTypedArray())
    }

    val targetResult = JimpleLocal("\$r${objectCounter++}", target.method.returnType)
    locals += targetResult

    val targetAssignStmt = assignStmt(targetResult, targetInvoke)
    units += targetAssignStmt

    val returnStmt = returnStatement(targetResult)
    units += returnStmt

    // update units with assertUnits
    units += assertUnits

    val body = units.toGraphBody()
    body.locals.addAll(locals)

    return createSootMethod(methodName, paramTypes, booleanType, sootClassVulnerabilityChecks, body)
}

fun createConstraintsFunction(methodName: String, argumentsList: List<List<Any>>, paramTypes: List<Type> = listOf(STRING_TYPE)): SootMethod {
    val cachedMethod = sootClassVulnerabilityChecksFunctions.getMethodByNameUnsafe(methodName)
    if (cachedMethod != null) {
        return cachedMethod
    }

    // helpers
    var objectCounter = 0
    val units = mutableListOf<Unit>()
    val locals = mutableSetOf<JimpleLocal>()

    // types
    val booleanType = BooleanType.v()

    // initialize parameter locals
    val parameterLocals = paramTypes.map {
        JimpleLocal("r${objectCounter++}", it)
    }
    locals += parameterLocals

    val parameterRefs = paramTypes.mapIndexed { idx, type  -> parameterRef(type, idx) }
    val identityStmts = parameterLocals.zip(parameterRefs) { local, ref -> identityStmt(local, ref) }
    units += identityStmts


    //
//    val result = orExpr(argumentsList.map { args ->
//        assert(args.size == paramTypes.size) { "wrong count arguments: ${args.size} != ${paramTypes.size} ($args, $paramTypes)" }
//        val values = args.zip(paramTypes).map { (arg, type) ->
//            when (type) {
//                STRING_TYPE -> StringConstant.v(arg as String)
//                else -> throw Exception("type $type not supported")
//            }
//        }
//        andExpr(parameterLocals.zip(values).map {
//            eqExpr(it.first, it.second)
//        })
//    })

    val result = eqExpr(parameterLocals.first(), StringConstant.v(argumentsList.first().first() as String))     // FIXME (always false)

    val resultLocal = JimpleLocal("\$r${objectCounter++}", booleanType)
    locals += resultLocal
    units += assignStmt(resultLocal, result)

    val returnStmt = returnStatement(resultLocal)
    units += returnStmt

    val body = units.toGraphBody()
    body.locals.addAll(locals)

    return createSootMethod(methodName, paramTypes, booleanType, sootClassVulnerabilityChecksFunctions, body)
}
