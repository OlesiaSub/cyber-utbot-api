# Notes

- В какой момент всё добавляется/отправляется на Z3? - [UtSolver](UtSolver.md) есть в [SymbolicState](SymbolicState.md), ограничения добавляются (_add_ в [UtSolver](UtSolver.md)) после каждой инструкции (итерации [Traverser](Traverser.md)), проверяются (_check_ в [UtSolver](UtSolver.md))  в _poll_ [PathSelector](PathSelector.md), если надо делать форк в графе (см. _checkUnsatIfFork_ [BasePathSelector](../../../../utbot-framework/src/main/kotlin/org/utbot/engine/selectors/BasePathSelector.kt)), если дошли до инструкции _return_ (см. _JReturnStmt_ в _traverseStmt_ [Traverser](Traverser.md)) и в некоторых других специфичных случаях.
- Когда и как появляются пути исполнения в [UtBotSymbolicEngine](UtBotSymbolicEngine.md)? - [UtBotSymbolicEngine](UtBotSymbolicEngine.md) идёт по [ExecutionState](ExecutionState.md), которые он получает от [PathSelector](PathSelector.md), в случае если исполнение может пойти по разному (в зависимости от контекста/переменных/чего-то ещё) создаются несколько состояний с ограничениями, соответствующими выбранному случаю. После этого они разбираются отдельно (можно сказать, что в графе в этот момент появилось (вернее оно там и так было, просто до него дошли) несколько независимых путей - разветвление).
- В каком порядке обрабатываются инструкции (ноды графа [InterProceduralUnitGraph](InterProceduralUnitGraph.md))? - всё зависит от [PathSelector](PathSelector.md). Изначально берётся [ExecutionState](ExecutionState.md) полученный из вершины графа (условно пустой), после на каждом шаге в [PathSelector](PathSelector.md) добавляются [ExecutionState](ExecutionState.md) которые можно достичь после посещения текущего [ExecutionState](ExecutionState.md). Какой из них следует посетить дальше определяется конкретной реализацией [PathSelector](PathSelector.md).
- Какой порядок действий в _traverse_ [UtBotSymbolicEngine](UtBotSymbolicEngine.md) в более общем виде? - какое-то описание этого есть в самом [UtBotSymbolicEngine](UtBotSymbolicEngine.md), более подробно по системе, но без деталей реализации, всё происходит в таком порядке на каждом шаге (в упрощённом случае, может отличаться в реальности):
  - берётся [ExecutionState](ExecutionState.md) из [PathSelector](PathSelector.md) (изначально там пустой дефолтный [ExecutionState](ExecutionState.md), если нечего брать - всё закончилось, выходит).
  - запускается _traverse_ [Traverser](Traverser.md). Он создаёт _TraversalContext_ (контекст во время обхода инструкции состояния, берёт тип конкретной [jimple](../abstract/Jimple.md) инструкции (_JIfStmt, JAssignStmt, JGotoStmt, ..._) и выполняет её обработку (может быть достаточно много всего, из базового, например, получает новое состояние и добавляет его в состояние созданного ранее _TraversalContext_). Возвращаются все состояния, записанные в этот _TraversalContext_.
  - проходится по каждому полученному состоянию и действует соответствующе (например, добавляет в возможные состояния [PathSelector](PathSelector.md), если это состояние промежуточное или запускает специальную обработку _consumeTerminalState_, если оно терминальное).
- Может ли большое число путей выполнения замедлять работу и как это может происходить? - Может, так как пути после разделения обрабатываются отдельно. [Пример](../../main/java/org/testcasesGen/execPaths/ManyPathsProblem.txt)
- В каком месте удобно останавливаться и смотреть как меняются ограничения, приходят инструкции? - Можно на `if (state == null) {` (т.е. после `val state = pathSelector.poll()`) в _traverseImpl_ [UtBotSymbolicEngine](../../../../utbot-framework/src/main/kotlin/org/utbot/engine/UtBotSymbolicEngine.kt).
